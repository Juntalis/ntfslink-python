# encoding: utf-8
"""
Win32 API Constants

This program is free software. It comes without any warranty, to
the extent permitted by applicable law. You can redistribute it
and/or modify it under the terms of the Do What The Fuck You Want
To Public License, Version 2, as published by Sam Hocevar. See
http://sam.zoy.org/wtfpl/COPYING for more details.
"""
from ctypes.wintypes import WORD, DWORD
from ctypes import c_ulonglong as QWORD

## Platform-Specific Invalid Values
# Used a number of times, so let's just calculate this once now and cache
# it forver.
INVALID_VALUE32 = DWORD(-1).value
INVALID_VALUE64 = QWORD(-1).value

##
FILE_ANY_ACCESS = 0
FILE_SPECIAL_ACCESS = FILE_ANY_ACCESS
FILE_READ_DATA = FILE_READ_ACCESS = 0x0001
FILE_WRITE_DATA = FILE_WRITE_ACCESS = 0x0002

## Generic access
GENERIC_READ    = 0x80000000
GENERIC_WRITE   = 0x40000000
GENERIC_EXECUTE = 0x20000000
GENERIC_ALL     = 0x10000000

## File sharing mode
FILE_SHARE_READ       = 0x00000001
FILE_SHARE_WRITE      = 0x00000002
FILE_SHARE_DELETE     = 0x00000004
FILE_SHARE_READ_WRITE = FILE_SHARE_READ | FILE_SHARE_WRITE
FILE_SHARE_ALL        = FILE_SHARE_READ_WRITE | FILE_SHARE_DELETE

## Creation flags
CREATE_NEW        = 1
CREATE_ALWAYS     = 2
OPEN_EXISTING     = 3
OPEN_ALWAYS       = 4
TRUNCATE_EXISTING = 5

## File open flags
#FILE_FLAG_OVERLAPPED            = 0x40000000
FILE_FLAG_BACKUP_SEMANTICS       = 0x02000000
FILE_FLAG_OPEN_REPARSE_POINT     = 0x00200000
FILE_FLAG_OPEN_REPARSE_DIRECTORY = FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS

## File attributes
FILE_ATTRIBUTE_NORMAL        = 0x00000080
FILE_ATTRIBUTE_HIDDEN        = 0x00000002
FILE_ATTRIBUTE_SYSTEM        = 0x00000004
FILE_ATTRIBUTE_READONLY      = 0x00000001
FILE_ATTRIBUTE_DIRECTORY     = 0x00000010
FILE_ATTRIBUTE_REPARSE_POINT = 0x00000400
FILE_ATTRIBUTE_INVALID       = 0xFFFFFFFF

## Filesystem Support
#FILE_UNICODE_ON_DISK          = 0x00000004
FILE_SUPPORTS_HARD_LINKS       = 0x00400000
FILE_SUPPORTS_REPARSE_POINTS   = 0x00000080
#FILE_SUPPORTS_OPEN_BY_FILE_ID = 0x01000000

## Access Types
# The following are masks for the predefined standard access types
DELETE = 0x00010000
READ_CONTROL = 0x00020000
WRITE_DAC = 0x00040000
WRITE_OWNER = 0x00080000
SYNCHRONIZE = 0x00100000

## Access flags for security tokens
TOKEN_ADJUST_PRIVILEGES = 0x0020

## SE privilege activation flags
SE_PRIVILEGE_ENABLED = 0x00000002
# SE_PRIVILEGE_REMOVED = 0X00000004L
# SE_PRIVILEGE_USED_FOR_ACCESS = 0x80000000L
# SE_PRIVILEGE_ENABLED_BY_DEFAULT = 0x00000001L

## Privilege Set Control flags
#PRIVILEGE_SET_ALL_NECESSARY = 1

## SE Privilege names
SE_BACKUP_NAME = 'SeBackupPrivilege'
SE_RESTORE_NAME = 'SeRestorePrivilege'

# Will only need the following if I try calling the CreateSymbolicLink Win32 API from Vista, which
# is an approach I already intend to avoid.
SE_CREATE_SYMBOLIC_LINK_NAME = 'SeCreateSymbolicLinkPrivilege'

#define REPARSE_GUID_DATA_BUFFER_HEADER_SIZE   FIELD_OFFSET(REPARSE_GUID_DATA_BUFFER, GenericReparseBuffer)

# Maximum allowed size of the reparse data.
MAX_NAME_LENGTH = 1024
MAX_REPARSE_BUFFER_SIZE = 16 * MAX_NAME_LENGTH

# Symbolic link flags
SYMBOLIC_LINK_FLAG_RELATIVE  = 1
SYMBOLIC_LINK_FLAG_FILE      = 0x00000000
SYMBOLIC_LINK_FLAG_DIRECTORY = 0x00000001

# Predefined reparse tags.
# These tags need to avoid conflicting with IO_REMOUNT defined in ntos\inc\io.h
IO_REPARSE_TAG_RESERVED_ZERO   = 0x00000000
IO_REPARSE_TAG_RESERVED_ONE    = 0x00000001

# The value of the following constant needs to satisfy the following conditions:
# (1) Be at least as large as the largest of the reserved tags.
# (2) Be strictly smaller than all the tags in use.
IO_REPARSE_TAG_RESERVED_RANGE  = IO_REPARSE_TAG_RESERVED_ONE

IO_REPARSE_TAG_HSM           = 0xC0000004
IO_REPARSE_TAG_HSM2          = 0x80000006
IO_REPARSE_TAG_SIS           = 0x80000007
IO_REPARSE_TAG_WIM           = 0x80000008
IO_REPARSE_TAG_CSV           = 0x80000009
IO_REPARSE_TAG_DFS           = 0x8000000A
IO_REPARSE_TAG_DFSR          = 0x80000012
IO_REPARSE_TAG_MOUNT_POINT   = 0xA0000003
IO_REPARSE_TAG_SYMBOLIC_LINK = 0xA000000C

## Control Codes
# Ported over macros and constants from the official system headers.
def CTL_CODE(DeviceType, Function, Method, Access):
	return (DeviceType << 16) | (Access << 14) | (Function << 2) | Method

def DEVICE_TYPE_FROM_CTL_CODE(ctrlCode):
	return (ctrlCode & 0xffff0000) >> 16

def METHOD_FROM_CTL_CODE(ctrlCode):
	return ctrlCode & 3

## File Device codes
FILE_DEVICE_FILE_SYSTEM = 0x00000009

## Method Directions
METHOD_NEITHER    = 3
METHOD_BUFFERED   = 0
METHOD_IN_DIRECT  = 1
METHOD_OUT_DIRECT = 2

## Extended Method Directions
METHOD_DIRECT_TO_HARDWARE   = METHOD_IN_DIRECT
METHOD_DIRECT_FROM_HARDWARE = METHOD_OUT_DIRECT

## Hardlink-Related Control Codes
FSCTL_GET_NTFS_FILE_RECORD = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 26, METHOD_BUFFERED, FILE_ANY_ACCESS)

## Reparse Point Specific Control Codes
FSCTL_SET_REPARSE_POINT    = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 41, METHOD_BUFFERED, FILE_ANY_ACCESS)
FSCTL_GET_REPARSE_POINT    = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 42, METHOD_BUFFERED, FILE_ANY_ACCESS)
FSCTL_DELETE_REPARSE_POINT = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 43, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_GET_NTFS_FILE_RECORD      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 26, METHOD_BUFFERED, FILE_ANY_ACCESS) // NTFS_FILE_RECORD_INPUT_BUFFER, NTFS_FILE_RECORD_OUTPUT_BUFFER

## Unused Control Codes
# FSCTL_FIND_FILES_BY_SID = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 35, METHOD_NEITHER, FILE_ANY_ACCESS)
# FSCTL_GET_COMPRESSION = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 15, METHOD_BUFFERED, FILE_ANY_ACCESS)
# FSCTL_SET_COMPRESSION = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 16, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA)
# FSCTL_GET_NTFS_VOLUME_DATA = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 25, METHOD_BUFFERED, FILE_ANY_ACCESS)              # NTFS_VOLUME_DATA_BUFFER
# FSCTL_FILESYSTEM_GET_STATISTICS = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 24, METHOD_BUFFERED, FILE_ANY_ACCESS)         # FILESYSTEM_STATISTICS
# FSCTL_SET_OBJECT_ID = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 38, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)                 # FILE_OBJECTID_BUFFER
# FSCTL_GET_OBJECT_ID = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 39, METHOD_BUFFERED,FILE_ANY_ACCESS)                      # FILE_OBJECTID_BUFFER
# FSCTL_DELETE_OBJECT_ID = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 40, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)              # FILE_OBJECTID_BUFFER

## Unused File Device codes
# FILE_DEVICE_CD_ROM = 0x00000002
# FILE_DEVICE_CD_ROM_FILE_SYSTEM = 0x00000003
# FILE_DEVICE_CONTROLLER = 0x00000004
# FILE_DEVICE_DATALINK = 0x00000005
# FILE_DEVICE_DFS = 0x00000006
# FILE_DEVICE_DISK = 0x00000007
# FILE_DEVICE_DISK_FILE_SYSTEM = 0x00000008
# FILE_DEVICE_MULTI_UNC_PROVIDER = 0x00000010
# FILE_DEVICE_NAMED_PIPE = 0x00000011
# FILE_DEVICE_NETWORK = 0x00000012
# FILE_DEVICE_NETWORK_BROWSER = 0x00000013
# FILE_DEVICE_NETWORK_FILE_SYSTEM = 0x00000014
# FILE_DEVICE_NULL = 0x00000015
# FILE_DEVICE_PARALLEL_PORT = 0x00000016
# FILE_DEVICE_PHYSICAL_NETCARD = 0x00000017
# FILE_DEVICE_PRINTER = 0x00000018
# FILE_DEVICE_SCANNER = 0x00000019
# FILE_DEVICE_SERIAL_MOUSE_PORT = 0x0000001a
# FILE_DEVICE_SERIAL_PORT = 0x0000001b
# FILE_DEVICE_SCREEN = 0x0000001c
# FILE_DEVICE_SOUND = 0x0000001d
# FILE_DEVICE_STREAMS = 0x0000001e
# FILE_DEVICE_TAPE = 0x0000001f
# FILE_DEVICE_TAPE_FILE_SYSTEM = 0x00000020
# FILE_DEVICE_TRANSPORT = 0x00000021
# FILE_DEVICE_UNKNOWN = 0x00000022
# FILE_DEVICE_VIRTUAL_DISK = 0x00000024

